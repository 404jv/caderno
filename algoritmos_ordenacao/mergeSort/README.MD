# ğŸ‘½ Merge Sort
Esse algoritmo assim como o [Quick Sort](../quickSort) sÃ£o algoritmos do tipo "Dividir e conquistar" Basicamente oque o Merge Sort faz Ã© dividir a lista em pequenas listas que vÃ£o ser chamadas de sublistas e apÃ³s a divisÃ£o ir ordendando as listas.

## ğŸª“ Dividir e Conquistar
TrÃªs passos simples que esse algoritmo vai seguir. </br>

- â— **Dividir** o problema em subproblemas
- ğŸª“ **Conquistar** resolver os subproblemas um por um `recursivamente`.
- ğŸ¤ **Unir** os subproblemas que foram divididos e resolvidos.

â— `Dividir` </br>
Agora explicando um pouco da parte mais tÃ©cnica, oque vamos fazer nesse passo Ã© descobrir o **meio** dessa lista, entÃ£o para isso basta somar a **esquerda** e **direita** da nossa lista, onde esquerda Ã© o Ã­ndice do primeiro elemento da lista e direita o Ã­ndice do Ãºltimo elemento da lista (precisamos colocar isso em variÃ¡veis pois nem sempre o primeiro elemento da lista Ã© 0 jÃ¡ que vamos dividir a mesma) E apÃ³s a soma da esquerda e a direita Ã© sÃ³ dividir por 2 arredondando para baixo.
Um exemplo disso seria:

```C
lista[10, 9, 4, 6, 5, 8, 3]
                m 
```
Aqui nÃ³s temos 7 elementos, entÃ£o a esquerda vale 0 e direita vale 7, ou seja, o meio dessa lista seria o Ã­ndice 3.

ğŸª“ `Conquistar` </br>
Nesse passo Ã© precisamos ordernar as duas sublistas criadas no passo da divisÃ£o, as listas sÃ£o:

**Esquerda**
```C
lista[esquerda...meio] // lista[10, 9, 4, 6]
```
**Direita**
```C
lista[meio+1...direita] // lista[5, 8, 3]
```

ğŸ¤ `Unir` </br>
Agora temos que unir as duas sublistas ordenadas devolta para a lista completa.


## ğŸ¾ Passo a Passo com baralhos
Vamos imaginar que eu e vocÃª estÃ¡ jogando um UNO e do nada eu tento explicar o merge sort para vocÃª, entÃ£o vamos lÃ¡.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/separacao1_qMdcEiN53.png" />

Esses primeiros passos sÃ£o bem simples Ã© sÃ³ dividir tudo recursivamente.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/separacao2_gyTZWabZJ.png" />

Ok dividimos uma lista em duas sublistas, agora essas sublistas tambÃ©m vÃ£o ter sublistas.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/separacao3_wRnkMT9Ip.png" />

Eta, tÃ¡ comeÃ§ando a ficar mais interessante, repara que aqui existe uma lista que tem suas sublistas e essa mesma lista Ã© sublista de outra.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/separacao4_T9FPLPRGu.png" />

Okay aqui nÃ³s terminamos de dividir tudo recursivamente, uma observaÃ§Ã£o Ã© que deixamos o 3 lÃ¡ em cima pois ele jÃ¡ estava sozinho entÃ£o nÃ£o precisamos colocar ele em uma outra sublista. Oque nÃ³s vamos fazer agora Ã© **conquistar**, vamos focar no 6 e 4 onde 6 Ã© a esquerda e 4 Ã© a direita. Comparando os dois nÃ³s vemos que a direita Ã© menor que a esquerda, ou seja, vamos colocar o 4 em cima primeiro.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/uniao1_WMbtoOOWLU.png" />

A nossa direita nÃ£o tem mais nenhum elemento entÃ£o vamos apenas jogar o nosso 6 para cima.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/uniao2_IrPIXyiXf_.png" />

Massa demais! agora Ã© sÃ³ ir repetindo, conquistar e unir, conquistar e unir... Para todas as nossas sublistas. Nas duas sublistas que tem o 10 e 8 vai ser a mesma coisa, nossa direita Ã© menor entÃ£o joga o 8 primeiro depois o 10.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/uniao3_CigPRHQF6s.png" />

EstÃ¡ vendo que conforme vamos terminando de "conquistar e unir" Algumas sublistas vÃ£o sumindo? Esse Ã© o poder da recursividade BB. Okay entÃ£o 5 e 9 nesse caso a nossa esquerda Ã© menor entÃ£o joga o 5 primeiro depois o 9.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/uniao4_4iYX5j4AMa.png" />

Massa! Agora as nossas sublistas tem mais de um elemento, repara que todas as nossas sublistas jÃ¡ estÃ£o ordenadas 4 e 6, 8 e 10, 5 e 9, 3 e nada.
Aqui nÃ£o vai ser diferente vamos pegar a esquerda [4, 6] e a direita [8, 10] e conquistar depois unir... Primeiro 4 Ã© menor que oito entÃ£o joga o 4, depois o 6 Ã© menor que oito entÃ£o joga o 6, nesse ponto a esquerda vai estÃ¡ vazia entÃ£o Ã© sÃ³ jogar o 8 e depois o 10 sem precisar fazer comparaÃ§Ãµes pois jÃ¡ sabemos que a direita jÃ¡ foi organizada assim como todas as outras sublistas.

Agora organizamos uma parte ficando [4, 6, 8, 10] agora precisamos focar nas duas sublistas [5, 9] que Ã© a esquerda e [3] que Ã© a direita. Vamos lÃ¡ 5 nÃ£o Ã© menor que 3 entÃ£o joga o 3 e logo apÃ³s isso joga o 5 e o 9 pois a direita ficou vazia, assim ficando [3, 5, 9].

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/uniao5_8qeEzYCKk.png" />

UAU! Que lindeza, para finalizar a nossa recursÃ£o vamos compara a esquerda [4, 6, 8, 10] e a direita [3, 5, 9], 4 nÃ£o Ã© menor que 3 entÃ£o sobe o 3, 4 Ã© menor que 5 entÃ£o sobe o 4... e assim comparando 6 com 5, 6 com 9, 8 com 9, 10 com 9 e finalmente sobrando apenas o 10 como nÃ£o tem nenhum elemento na direita entÃ£o sobe o 10.

<img src="https://ik.imagekit.io/dwei78ukbe/quick_sort/finalizado_hz5Bk71SE.png" />

ğŸ¾ E pronto!! A lista foi organizada com o merge sort um dos algoritmos de oredenaÃ§Ã£o mais poderosos ğŸ¦¸â€â™‚ï¸,  se vocÃª estÃ¡ com dificuldades saiba que para entender esse algoritmo complexo precisa de tempo, prÃ¡tica e uma boa pausa sempre vai ser bem-vinda para o seu cÃ©rebro assimilar tudo.

ğŸ§  VocÃª pode aprender qualquer coisa e atÃ© a prÃ³xima.

---
<p align="center">Feito com ğŸ’š por JoÃ£o Victor Ramalho Alves</p>
